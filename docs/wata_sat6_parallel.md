# wata_sat6_parallel.rs アルゴリズム詳細解説

## 概要

`wata_sat6_parallel.rs`は、ICFPC 2025コンテストにおけるTeam Unagiの多重化グラフ探索問題に対するSATソルバーベースの解法です。このアルゴリズムは、一段階アプローチ（One-Stage Approach）を採用し、グラフの構造と多重化の両方を単一のSAT問題として同時に解決します。

### 問題設定

ICFPC 2025では、参加者は「Aedificium」と呼ばれる迷路のような構造を探索し、その完全な地図を再構築する必要があります。問題の特徴：

- 各部屋には0-3の署名（signature）が割り当てられている
- 各部屋には最大6つのドアがある
- グラフは多重化されており、元のグラフが複数層に複製されている
- 探索中に部屋に印を付けることで状態を変更できる
- 最小のクエリ数で正確な地図を再構築することが目標

## アルゴリズムの主要コンポーネント

### 1. バランス探索計画生成（balanced_plan関数）

```rust
fn balanced_plan(len: usize, m: usize, rng: &mut impl Rng) -> Vec<usize>
```

この関数は、探索の効率性を最大化するためのバランスの取れた探索計画を生成します：

- **目的**: 各ドア（0-5）を均等に使用する探索パスを生成
- **手法**: 
  1. 長さ`len`のベクターを作成
  2. 各位置に`i % m`を割り当て（mは通常6）
  3. ランダムシャッフルで順序をランダム化
- **効果**: 全てのドアを均等に探索することで、グラフ構造の情報を最大限収集

### 2. 探索結果検証（gacha関数）

```rust
fn gacha(n: usize, plan: &[(Option<usize>, usize)], labels: &[usize]) -> f64
```

この関数は、探索結果が期待される分布に従っているかを検証します：

- **目的**: 探索結果の「運の良さ」を数値化
- **計算方法**:
  1. 各署名（0-3）と各ドア（0-5）の組み合わせの出現回数を集計
  2. 期待値（均等分布）との二乗誤差を計算
  3. 誤差が閾値（0.0010）を超える場合は「unlucky」として処理を中断
- **意義**: SATソルバーが解けない「不運な」ケースを早期に検出し、計算資源を節約

### 3. SAT変数エンコーディング

#### 3.1 頂点位置変数（V[t][u]）

```rust
let mut V = mat![!0; labels.len(); n];
for t in 0..labels.len() {
    for u in 0..n {
        V[t][u] = cnf.var();
    }
    cnf.choose_one(&V[t]);
}
```

- **意味**: 時刻tの開始時点で頂点uにいることを表すブール変数
- **制約**: 各時刻において、ちょうど一つの頂点にいる（choose_one制約）
- **初期化**: 開始頂点sを署名から特定し、V[0][s]をtrueに設定

#### 3.2 隣接関係変数（A[u][e][v]）

```rust
let mut A = mat![!0; n; 6; n];
for u in 0..n {
    for e in 0..6 {
        for v in 0..n {
            A[u][e][v] = cnf.var();
        }
        cnf.choose_one(&A[u][e]);
    }
}
```

- **意味**: 頂点uのドアeが頂点vに接続されることを表す
- **制約**: 各ドアは正確に一つの頂点に接続される

#### 3.3 エッジ接続変数（E[u][e][v][f]）

```rust
let mut E = mat![!0; n; 6; n; 6];
for u in 0..n {
    for e in 0..6 {
        for v in 0..n {
            for f in 0..6 {
                if E[u][e][v][f] == !0 {
                    E[u][e][v][f] = cnf.var();
                    E[v][f][u][e] = E[u][e][v][f]; // 対称性
                }
            }
        }
    }
}
```

- **意味**: 頂点uのドアeが頂点vのドアfに接続されることを表す
- **対称性**: E[u][e][v][f] = E[v][f][u][e]（無向グラフ）
- **制約**: 各ドアペアに対して最大一つの接続

#### 3.4 状態反転変数（F[u][e]）

```rust
let mut F = mat![!0; n; 6];
for u in 0..n {
    for e in 0..6 {
        F[u][e] = cnf.var();
    }
}
```

- **意味**: 頂点uのドアeが状態反転（多重化層の切り替え）を引き起こすかを表す
- **伝播制約**: 接続されたドア間で状態反転の一貫性を保証

#### 3.5 グローバル状態変数（S[t]）

```rust
let mut S = vec![!0; labels.len()];
for t in 0..labels.len() {
    S[t] = cnf.var();
}
```

- **意味**: 時刻tでの多重化層の状態（0層または1層）
- **初期状態**: S[0] = false（0層から開始）
- **状態遷移**: ドア通過時にF[u][e]に基づいて状態が変化

#### 3.6 色変数（C[t][ui][c]）

```rust
let mut C = mat![!0; labels.len(); n * 2; 4];
for t in 0..labels.len() {
    for ui in 0..n * 2 {
        for c in 0..4 {
            C[t][ui][c] = cnf.var();
        }
        cnf.choose_one(&C[t][ui]);
    }
}
```

- **意味**: 時刻tで頂点ui（多重化後の頂点）の色がcであることを表す
- **多重化**: 各元頂点uに対してu*2（0層）とu*2+1（1層）の2つの頂点
- **色制約**: 観測された署名と一致する必要がある

### 4. 制約の詳細

#### 4.1 移動制約

```rust
for u in 0..n {
    for v in 0..n {
        // V[t][u] & A[u][e][v] -> V[t+1][v]
        cnf.clause([-V[t][u], -A[u][e][v], V[t + 1][v]]);
    }
}
```

現在の頂点と使用するドアから次の頂点を決定する制約。

#### 4.2 状態遷移制約

```rust
// S[t] & V[t][u] & F[u][e] -> !S[t+1]
cnf.clause([-S[t], -V[t][u], -F[u][e], -S[t + 1]]);
// S[t] & V[t][u] & !F[u][e] -> S[t+1]
cnf.clause([-S[t], -V[t][u], F[u][e], S[t + 1]]);
```

現在の状態、位置、ドアの状態反転フラグに基づいて次の状態を決定。

#### 4.3 色観測制約

```rust
// V[t][u] & !S[t] -> C[t][u0][labels[t]]
cnf.clause([-V[t][u], S[t], C[t][u * 2][labels[t]]]);
// V[t][u] & S[t] -> C[t][u1][labels[t]]
cnf.clause([-V[t][u], -S[t], C[t][u * 2 + 1][labels[t]]]);
```

観測された署名と現在の位置・状態の一貫性を保証。

#### 4.4 色変更制約

```rust
if let Some(newc) = plans[t].0 {
    // V[t][u] & !S[t] -> C[t+1][u0][newc]
    cnf.clause([-V[t][u], S[t], C[t + 1][u * 2][newc]]);
}
```

印を付ける操作による色の変更を処理。

### 5. 並列SAT求解

```rust
solve_no_marks::solve_cnf_parallel(&mut cnf, 25, 25);
```

この関数は複数のSATソルバーを並列実行します：

- **ソルバー**: CaDiCaLとKissatを使用
- **並列度**: 25個のプロセスを同時実行
- **タイムアウト**: 25秒
- **戦略**: 異なる設定のソルバーを並列実行し、最初に解を見つけたものを採用

### 6. 解の抽出

```rust
let mut guess = Guess {
    start: s * 2,
    graph: vec![[(!0, !0); 6]; judge.num_rooms()],
    rooms: vec![0; judge.num_rooms()],
};
```

SAT解から最終的なグラフ構造を構築：

1. **開始頂点**: 多重化後の頂点インデックス（s * 2）
2. **部屋の署名**: 元の署名配列Lから復元
3. **グラフ構造**: E変数の真値からエッジ接続を構築
4. **状態反転**: F変数に基づいて適切な層間接続を設定

## 使用ライブラリ

### 1. icfpc2025フレームワーク

- **judge::Guess**: 最終的な推測結果の構造体
- **solve_no_marks::Cnf**: SAT問題の構築と求解
- **solve_no_marks::solve_cnf_parallel**: 並列SAT求解
- **mat!マクロ**: 多次元配列の初期化

### 2. 外部ライブラリ

- **itertools::Itertools**: イテレータの拡張機能（collect_vec等）
- **rand::prelude::***: 乱数生成（探索計画のシャッフル）

### 3. SAT ソルバー（間接使用）

- **CaDiCaL**: 高性能なSATソルバー
- **Kissat**: 軽量で高速なSATソルバー

## Team Unagiのアプローチにおける位置づけ

このアルゴリズムは、Team Unagiの「一段階アプローチ」の実装例です：

1. **二段階アプローチとの違い**: グラフ構造の特定と多重化の解析を同時に行う
2. **適用範囲**: 比較的小さな問題（daleth(2*24)等）で効果的
3. **利点**: 全情報を同時に活用することで、より良いスコアを達成
4. **制限**: SAT問題が大きくなるため、大規模問題では時間がかかる

## 計算複雑度と性能

- **変数数**: O(T × N × D) （T:時刻数、N:頂点数、D:ドア数）
- **制約数**: O(T × N² × D²)
- **メモリ使用量**: 数GB（大規模問題）
- **実行時間**: 数分〜数十分（問題サイズに依存）

## まとめ

`wata_sat6_parallel.rs`は、ICFPC 2025の多重化グラフ探索問題に対する洗練されたSATベースの解法です。バランスの取れた探索戦略、包括的なSAT変数エンコーディング、並列求解により、最小のクエリ数で正確な地図再構築を実現します。Team Unagiの総合的なアプローチの中で、中規模問題に対する効果的な解法として位置づけられています。
